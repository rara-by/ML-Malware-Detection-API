import os
import logging
import joblib
import numpy as np
from scipy.sparse import coo_matrix
import sys
import io
import json

module_path = os.path.abspath('/opt/ml/code')
if module_path not in sys.path:
    sys.path.append(module_path)



def model_fn(model_dir):
    logging.info("MODEL_FN")
    clf = joblib.load(os.path.join(model_dir, "model.joblib"))
    logging.info("model loaded")
    return clf


def input_fn(input_data, content_type):
    """Parse input data payload
    """
    if content_type == 'application/json':
        # Parse JSON request body
        
        payload = json.loads(input_data)
        payload = json.loads(payload)
        logging.info("PAYLOAD LOADED") # {}".format(type(payload), payload['shape']))
        
        # Extract COO matrix components from JSON payload
        data = np.array(payload['data'])
        row = np.array(payload['row'])
        col = np.array(payload['col'])
        shape = tuple(payload['shape'])
        
        # Reconstruct COO matrix
        input_data = coo_matrix((data, (row, col)), shape=shape)
        logging.info("COO MATRIX RETRIEVED")

        return input_data
         
    else:
        raise ValueError("{} not supported by script!".format(content_type))
        
        
def predict_fn(input_data, model):
    logging.info('Predict fn shape: {}'.format(input_data.shape))
    prediction = model.predict(input_data)
    logging.info("PREDICTION")
    
    return np.array(prediction)


def output_fn(prediction, content_type):
    """Serialize the prediction output."""
    if content_type == 'application/json':
        # Convert the prediction output (a NumPy array) into a JSON serializable format
        if prediction == np.array([1]):
            label = "malware"
        else:
            label = "benign"
            
        serialized_output = {
            'prediction': prediction.tolist(),  # Convert the NumPy array to a list
            'label': label
        }
        
        # Serialize the output dictionary to JSON
        json_output = json.dumps(serialized_output)
        logging.info("OUTPUT")
        
        return json_output
    
    else:
        raise ValueError(f'Unsupported content type: {content_type}')

if __name__ == "__main__":
    model = model_fn("")
    x = input_fn(input_data=np.array(['Training a Static Malware Detector/Code/Samples/Benign/file-uri.exe'])
        , content_type= 'application/x-npy')
    p = predict_fn(x, model)
    print(p)